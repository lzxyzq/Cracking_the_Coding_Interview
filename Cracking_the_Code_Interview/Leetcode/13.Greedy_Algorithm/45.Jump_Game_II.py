# Given an array of non-negative integers, you are initially positioned at the first index of the array.
# Each element in the array represents your maximum jump length at that position.
# Your goal is to reach the last index in the minimum number of jumps.

""" 
Example:

Input: [2,3,1,1,4]
Output: 2
Explanation: The minimum number of jumps to reach the last index is 2.
    Jump 1 step from index 0 to 1, then 3 steps to the last index.
"""

# The main idea of BFS solution is: try to find the “range” which represents all the nodes can be reached in every single jump. We first define the parameter “level” to stand for the BFS level of all the jumps. Every time when we are trying to make a jump, we go through all the nodes in nums[i:preStep] and try to expand the BFS range, where “i” is the current position and “preStep” is the range generated by the previous jump. Then, we store the range in the defined parameter “curStep” and update “preStep” before we go traverse all the nodes.

class Solution:
    def jump(self, nums: List[int]) -> int:
        cur = 0 
        last_pos = len(nums) - 1
        jump_num = 0
        while cur < last_pos:
            jump_num += 1
            pre = cur
            for i in range(pre+1):
                cur = max(cur,i+nums[i])
        return jump_num

# TLE [1,1,1,1,1,……]

# Method 2 

# I will start from a position and look at the position I can go from here
# now, I know that from current position to the position where I can go I just need to make one jump for each point between these two positions
# now I will look at the point from where I can make the max jump between these two points(including the end)
# and I will keep on carrying this.
# Basically I will look between the current position and the max position and find the next jump that I can make.
# So basically adding 1 jump at a time.

class Solution:
    def jump(self, nums: List[int]) -> int:
        ln = len(nums)
        if ln <= 1:
            return 0
    
        cnt = till = 0
        maxIdx = 0 
        for i in range(ln):
            maxIdx = max(maxIdx, i + nums[i])
            if i == till:
                cnt += 1
                till = maxIdx 
        
            if till >= ln-1:
                return cnt
            
        